<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[design-patterns]]></title>
    <url>%2Fblog%2Fdist%2F2020%2F09%2F21%2Fdesign-patterns%2F</url>
    <content type="text"><![CDATA[设计模式 细节分类 【发布订阅模式】vue 中的实现$on,$emit,$off 【单例模式】errorDialog 可以使用进行优化 【策略模式】vue 中的 form rule，配置化使用，map 结构提供策略可配置，环境类的去调用 map 中的实际方案（value）去执行，Monitor 校验配置使用的 { key: ()=&gt;{} } 【代理模式】防抖节流， Proxy, defineProperty， 主要是替代访问本体的功能 【中介者模式】目的，减少耦合，eg: 购物车需求,redux, vuex 都是中介者模式，通过 store 这个中介来操作对象 【装饰器模式】eg: react 高阶组件, 主要是添加行为。 【外观模式】外面只调用一个函数， 内部判断不同的分支，实现具体的逻辑 【工厂模式】提供一个专门创建对象的接口 【建造者模式】和工厂模式相比，参与了更多创建的过程 或者更为复杂 【迭代器模式】 【享元模式】重复利用一个模特，穿不同的衣服 【责任链模式】中间件机制，每个中间件串行的对你的东西进行加工判断处理 【适配器模式】理解为外观模式？ 大分类 创建型设计模式 构造器模式 原型模式 工厂模式 提供一个接口实现创建，接口内部才是调用new Class() abstract factory 抽象工厂 内部的class可以通过接口进行注册 单例模式 prototype模式 object.create(obj, {}) 实际原理是函数委托给别人 module模式 闭包自执行函数，暴露一个变量给外部使用，通过变量来操作内部私有属性 抽象模式 生成器模式（可以理解为一个生成器中包含了多个类的实例化，复杂化后的工厂模式） 结构型设计模式（专注类和对象的组合） 代理模式 提供一个代理者去帮助你操作实际的内容，代理者会考虑容错场景，提供备选方案(loading 图片的展示，等实际加载完图片，再切换新的src) 外观模式 外部调用统一，内部实现进行判断兼容性 Command（命令）模式 通过不同的命令（传参）做不同的事情，常含有（关联）接收者 execute(‘requestInfo’, ‘Ford Mondeo’, ‘321’) execute(‘buyVehicle’, ‘Ford Escort’, ‘789’) Facade（外观）模式 Mixin模式 类似于extend, merge等函数，将两个对象的key合并成一个，重复的以优先级进行覆盖 Decorator（装饰器）模式 Flyweight（享元）模式 行为设计模式 观察者（发布订阅者模式） 关注对象之间的通信 策略模式 不同的算法做同一件事情 设计原则 人月神话 代码大全 unix编程艺术 开放封闭，开放扩展，封闭修改 依赖倒转 单一职责 里式替换 合成复用 组合优于继承 学习设计模式的目的： 写着舒服，维护更舒服 什么时候用 带来开发收益 带来可维护性收益 把设计模式和组件挂钩（elementUI, antDesign） 没有这些，if else 就是最简单的代码 不要滥用 懒，才是程序员成长的动力 项目内部设计原则 布鲁克斯法则： 软件开发的后期，添加人力，会让项目更慢 KISS 原则：保持简单,simple and stupid 模块设计需要遵循 备份 软件开发没有银弹 过早优化效应 过早的优化是万恶之源 学习感言 - 代码处处是模式，其实设计模式的大白话就是套路，大家都实践过很多遍之后得出的真理。学习中间，就会发现，其实自己的代码当中很多地方已经用到了设计模式，只是你自己不知道那叫什么名字]]></content>
      <categories>
        <category>desgin-patterns</category>
      </categories>
      <tags>
        <tag>desgin-patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protractor]]></title>
    <url>%2Fblog%2Fdist%2F2020%2F04%2F04%2Fprotractor%2F</url>
    <content type="text"><![CDATA[protractorSource Code]]></content>
      <categories>
        <category>protractor</category>
      </categories>
      <tags>
        <tag>e2e</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt]]></title>
    <url>%2Fblog%2Fdist%2F2019%2F08%2F27%2Fgrunt%2F</url>
    <content type="text"><![CDATA[grunt 安装环境 npm init -y grunt npm install grunt --save-dev grunt-cli npm install grunt-cli -g, 这里我是全局安装grunt-cli 配置文件 在package.json同级目录下，创建Gruntfile.js文件 123module.exports = function(grunt) &#123; // Do grunt-related things in here&#125;; 为工程增加babel转义功能 为何要这么做？ 由于现代浏览器对es6+的语法支持度不够高，对于…解构、async/await 等无法识别，所以需要将我们的代码编译为浏览器认识的代码（方便我们使用最新的语法去编写代码，使代码更清晰明了高大上） 安装依赖 npm install --save-dev grunt-babel @babel/core npm install @babel/preset-env --save-dev 配置文件 Gruntfile.js 1234567891011121314151617181920212223242526require("load-grunt-tasks")(grunt); // npm install --save-dev load-grunt-tasksgrunt.initConfig(&#123; "babel": &#123; options: &#123; sourceMap: false, presets: [ [ '@babel/preset-env', &#123; targets: &#123; browsers: ['&gt; 1%', 'last 2 versions', 'not ie &lt;= 8'] &#125; &#125; ] ] &#125;, dist: &#123; files: &#123; "dist/app.js": "src/app.js" &#125; &#125; &#125;&#125;);grunt.registerTask("default", ["babel"]); 1grunt.loadNpmTasks(&apos;grunt-babel&apos;); - `@babel/core` 是实际用来转义es6+代码的 - `@babel/preset-env`是做转义预设，指定转义规则的 为环境增加全局变量babel-polyfill 为何要这样做？ 当babel转义后，其实还有一些东西无法转义，比如es6+中的全局变量中的Promise, Object.assign()方法等，这就需要我们对当前环境进行一个polyfill，填充他们缺少的功能。（如果不填充，浏览器如果不认识Promise，那肯定运行的时候报错噻） 安装依赖 npm install --save-dev @babel/polyfill 配置文件 Gruntfile.js 12345678910111213presets: [ [ '@babel/preset-env', &#123; targets: &#123; browsers: ['&gt; 1%', 'last 2 versions', 'not ie &lt;= 8'] &#125;, modules: 'commonjs', // 选项用于模块转化规则设置，可选配置包括："amd" | "umd" | "systemjs" | "commonjs" | false, 默认使用 "commonjs"。即，将代码中的ES6的import转为require。 corejs: '3', // 声明corejs版本 useBuiltIns: 'usage' // 不用显示引用@babel/polyfill &#125; ] ] 为环境增加browserify功能 为何这样做 我们会发现babel转义出来的代码里面，会有require()/import语法，这都是引入的polyfill，但是浏览器不认识require() 这种commonJs 的CMD语法，也不认识import/exports 等语法，必须转换为浏览器认识的。 browserify默认是将require进行转换。 对前端define的转换还不知道怎么配置。 安装依赖 npm install --save-dev browserify npm install --save-dev grunt-browserify 配置文件 Gruntfile.js 12345678910111213// 让浏览器适配require(commonJS,CMD) browserify: &#123; dist: &#123; files: [ &#123; expand: true, src: ['**/*.js'], //所有js文件 dest: tmpDirBabel, //输出到此目录下 cwd: tmpDirBabel //js目录下 &#125; ] &#125; &#125; 1grunt.loadNpmTasks(&apos;grunt-browserify&apos;); 配置压缩功能 为何这样做？ js文件进行压缩体积，优化方向 安装依赖 npm install grunt-contrib-uglify --save-dev 配置文件 Gruntfile.js 1234567891011121314151617// 自定义压缩 uglify: &#123; options: &#123; mangle: true, //混淆变量名 comments: 'false' //false（删除全部注释），some（保留@preserve @license @cc_on等注释） &#125;, uglifyFile: &#123; files: [ &#123; expand: true, src: ['**/*.js'], //所有js文件 dest: tmpDirBabel, //输出到此目录下 cwd: tmpDirBabel //js目录下 &#125; ] &#125; &#125; 1grunt.loadNpmTasks('grunt-contrib-uglify'); 配置监听 为何这么做？ 当文件发生更改时，需要做的一些任务，通常配置dev环境，比如less的编译， 本地js的转义等 安装依赖 npm install grunt-contrib-watch grunt-contrib-livereload --save-dev 配置文件 Gruntfile.js 123456789101112131415161718192021watch: &#123; js: &#123; files: ['localApp/**/*.js'], //所有js tasks: [ 'babel', 'browserify' ], options: &#123; interrupt: true, // 如果文件再次更改，则停止上一次的任务，重新构建新的 livereload: true &#125; &#125;, others: &#123; files: ['localApp/**/*', '!localApp/**/*.js'], // 除了js tasks: ['copy:copyOthersToWebApp'], options: &#123; interrupt: true, livereload: true &#125; &#125; &#125; 12grunt.loadNpmTasks('grunt-contrib-watch');grunt.loadNpmTasks('grunt-contrib-livereload'); 加载npm任务 1grunt.loadNpmTasks('grunt-babel'); 注册自定义任务 1grunt.registerTask('dev', ['watch']);]]></content>
      <categories>
        <category>自动化构建</category>
      </categories>
      <tags>
        <tag>自动化构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6Class]]></title>
    <url>%2Fblog%2Fdist%2F2019%2F03%2F04%2Fes6Class%2F</url>
    <content type="text"><![CDATA[es6中class的基本使用 有几个关键字的使用： class： 用来定义’类’； constructor： 用来初始化’类’； extends： 用来子类继承父类； super： 调用父类方法 区分一： constructor 中，直接调用super()并传参，相当于调用父级的constructor； 区分二：普通方法中（原型方法），super指向父类的原型对象，调用super.xx()， xx指代父级的某个方法； 示例代码： 1234567891011121314151617181920212223242526272829// 基类-动物class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name, '--------基类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Animal中的方法'); &#125;&#125;let animal = new Animal('小动物');animal.sayName();// 子类，狗--继承于动物类class Dog extends Animal &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; sayName() &#123; // 调用父类方法 super.sayName(); // 写子类自己的方法 console.log(`$&#123;this.name&#125;($&#123;this.age&#125;)----------子类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dog类中的方法`); &#125;&#125;let dog = new Dog('大黄', '7');dog.sayName(); 简不简单，惊不惊喜，意不意外，开不开心？ class使用就是这么简单，但是要知道这只是语法糖，es5中继承是如何实现呢？ es5中继承的基本实现 几个关键字的使用： function：类就是使用函数创建出来的； prototype：原型属性； Object.create(__proto__, obj)：用来创建对象 参数一__proto__：必需，被创建对象的原型对象。 参数二obj：可选，包含一个或多个属性描述符的 JavaScript 对象，用来规定要被添加到对象的属性，可以分为两类，数据属性和访问器属性 简单使用示例代码(从基本示例中引发思考，如何调用父级方法)： 1234567891011121314151617181920212223// 基类-动物function Animal(name) &#123; this.name = name;&#125;Animal.prototype.sayName = function() &#123; console.log(this.name, '--------基类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Animal中的方法');&#125;// 子类，狗--继承于动物类function Dog(name, age) &#123; this.name = name; this.age = age;&#125;// 将Dog的原型指向Animal的一个实例Dog.prototype = new Animal();// 因为Animal的实例可以调用Animal原型中的方法, 所以Dog的实例也可以调用Animal原型中的所有属性。Dog.prototype.sayName = function(argument) &#123; console.log(`$&#123;this.name&#125;($&#123;this.age&#125;)----------子类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dog类中的方法`);&#125;var dog = new Dog('大黄', '7');dog.sayName(); es6class创建和es5中function创建，异同点在哪里？ 相同点： 都分为声明式和表达式 对待name,length表现一致 对待创建变量结果一致*** fn对待相同，都可以用call,apply.bind来改变this指向 不同点： 声明式，es5中的fn是存在变量提升的，es6中的class没有 Dog类， fn创建可以使用call调用，class创建的不能 在全局中创建Dog类，fn可以在window中访问Dog,class生成的不能 武昌补充。。。我没琢磨粗来 那在es6还没出来的时候，当初的开发人员是如何写类的继承呢？别天真了，人没有那么傻，别个早已经封装实现了此类方法。 sorry,您的浏览器不支持该视频类型! 看看es5的时候，别个是如何使用继承的 1234567891011121314151617181920212223242526272829303132// 基类-动物var Animal = Class.extend(&#123; // init是构造函数，起到contructor的作用 init: function(name) &#123; this.name = name; &#125;, sayName: function() &#123; console.log(this.name, '--------基类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Animal中的方法'); &#125;&#125;);var animal = new Animal('小动物');animal.sayName();// 子类，狗--继承于动物类var Dog = Animal.extend(&#123; // init是构造函数 init: function(name, age) &#123; // 在构造函数中调用父类的构造函数 this._super(name); this.age = age; &#125;, sayName: function() &#123; // 调用父类方法 this._super(); // 写子类自己的方法 console.log(`$&#123;this.name&#125;($&#123;this.age&#125;)----------子类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dog类中的方法`); &#125;&#125;);var dog = new Dog('大黄', '7');dog.sayName(); 看过别人的继承使用效果后，我们来实现一个类似的手动实现原型继承 示例看基本的继承 12345678910111213141516171819202122// 基类-动物function Animal(name) &#123; this.name = name;&#125;Animal.prototype.sayName = function() &#123; console.log(this.name, '--------基类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Animal中的方法');&#125;// 子类，狗--继承于动物类function Dog(name, age) &#123; this.name = name; this.age = age;&#125;// 将Dog的原型指向Animal的一个实例Dog.prototype = new Animal();// 因为Animal的实例可以调用Animal原型中的方法, 所以Dog的实例也可以调用Animal原型中的所有属性。Dog.prototype.sayName = function() &#123; console.log(`$&#123;this.name&#125;($&#123;this.age&#125;)----------子类&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dog类中的方法`);&#125;var dog = new Dog('大黄', '7');dog.sayName(); 上述示例的缺陷： 在创建Dog构造函数和原型时，就对Animal进行了实例化，这是不合适的。 Dog的构造函数没法调用父类Animal的构造函数，导致在Dog构造函数中对name属性的重复赋值。 Dog中的函数会覆盖Animal中的同名函数，没有重载的机制（和上一条是一个类型的问题）。 实现中有constructor属性的指向错误。 单一职责，不够通用。 我们将其一个一个缺陷进行解决，最后便可以得到我们想要的封装结构,下面是完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Class = (function() &#123; // 标识类的初始化是否完成，如果完成，便可以调用init进行初始化构造函数 var initCompleteStatus = false; // 定义正则，边界为_super完整的字符串则是真 var reg = /\b_super\b/; function parentClass() &#123;&#125; // 父级，初始化基类是空对象 parentClass.extend = function(props) &#123; function childClass() &#123; if (initCompleteStatus) &#123; this.init.apply(this, arguments); &#125; &#125; var _super = this.prototype; // 父级类的原型 // 保存父级的所有属性为子类的原型，并重置constructor initCompleteStatus = false; // 此时的实例化不会调用init childClass.prototype = new this(); initCompleteStatus = true; Object.defineProperty(childClass.prototype, "constructor", &#123; value: childClass &#125;); // 自身属性的赋值 for (var name in props) &#123; if (typeof props[name] === "function" &amp;&amp; reg.test(props[name])) &#123; childClass.prototype[name] = (function(name, fn) &#123; return function() &#123; console.dir(Object.toString.call(fn)); var temp = this._super; this._super = _super[name]; // 拿到函数返回值 var result = fn.apply(this, arguments); this._super = temp; // 将返回值返回 return result; &#125;; &#125;)(name, props[name]); &#125; else &#123; childClass.prototype[name] = props[name]; &#125; &#125; childClass.extend = arguments.callee; return childClass; &#125;; return parentClass;&#125;)();]]></content>
      <categories>
        <category>class</category>
        <category>prototype</category>
      </categories>
      <tags>
        <tag>class</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-实现标准Promise规范]]></title>
    <url>%2Fblog%2Fdist%2F2019%2F01%2F02%2Fpromise%2F</url>
    <content type="text"><![CDATA[原文：BAT前端经典面试问题：史上最最最详细的手写Promise教程 es6出现了Promise,es7出现了async，基于Promise的实现，写出来一套同步洗写法的语法糖。掌握Promise的实现原理至关重要： 可以参照promisesA+规范 Promise 的声明首先呢，promise肯定是一个类，我们就用class来声明。 由于new Promise((resolve, reject)=&gt;{})，所以传入一个参数（函数），叫他executor，传入就执行。executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。由于resolve和reject可执行，所以都是函数，我们用let声明。 1234567891011class Promise&#123; // 构造器 constructor(executor)&#123; // 成功 let resolve = () =&gt; &#123; &#125;; // 失败 let reject = () =&gt; &#123; &#125;; // 立即执行 executor(resolve, reject); &#125;&#125; 解决基本状态Promise规定： Promise存在三个状态（state）pending、fulfilled、rejected pending（等待态）为初始态，并可以转化为fulfilled（成功态）和rejected（失败态） 成功时，不可转为其他状态，且必须有一个不可改变的值（value） 失败时，不可转为其他状态，且必须有一个不可改变的原因（reason） new Promise((resolve, reject)=&gt;{resolve(value)}) resolve为成功，接收参数value，状态改变为fulfilled，不可再次改变。 new Promise((resolve, reject)=&gt;{reject(reason)}) reject为失败，接收参数reason，状态改变为rejected，不可再次改变。 若是executor函数报错 直接执行reject(); 于是乎，我们获得以下代码 12345678910111213141516171819202122232425262728293031323334class Promise&#123; constructor(executor)&#123; // 初始化state为等待态 this.state = 'pending'; // 成功的值 this.value = undefined; // 失败的原因 this.reason = undefined; let resolve = value =&gt; &#123; // state改变,resolve调用就会失败 if (this.state === 'pending') &#123; // resolve调用后，state转化为成功态 this.state = 'fulfilled'; // 储存成功的值 this.value = value; &#125; &#125;; let reject = reason =&gt; &#123; // state改变,reject调用就会失败 if (this.state === 'pending') &#123; // reject调用后，state转化为失败态 this.state = 'rejected'; // 储存失败的原因 this.reason = reason; &#125; &#125;; // 如果executor执行报错，直接执行reject try&#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125;&#125; then方法Promise有一个叫做then的方法，里面有两个参数：onFulfilled,onRejected,成功有成功的值，失败有失败的原因 当状态state为fulfilled，则执行onFulfilled，传入this.value。当状态state为rejected，则执行onRejected，传入this.reason onFulfilled,onRejected如果他们是函数，则必须分别在fulfilled，rejected后被调用，value或reason依次作为他们的第一个参数 1234567891011121314class Promise&#123; constructor(executor)&#123;...&#125; // then 方法 有两个参数onFulfilled onRejected then(onFulfilled,onRejected) &#123; // 状态为fulfilled，执行onFulfilled，传入成功的值 if (this.state === 'fulfilled') &#123; onFulfilled(this.value); &#125;; // 状态为rejected，执行onRejected，传入失败的原因 if (this.state === 'rejected') &#123; onRejected(this.reason); &#125;; &#125;&#125; 解决异步实现现在基本可以实现简单的同步代码，但是当resolve在setTomeout内执行，then时state还是pending等待状态 我们就需要在then调用的时候，将成功和失败存到各自的数组，一旦reject或者resolve，就调用它们类似于发布订阅，先将then里面的两个函数储存起来，由于一个promise可以有多个then，所以存在同一个数组内。 1234// 多个then的情况let p = new Promise();p.then();p.then(); 成功或者失败时，forEach调用它们 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Promise&#123; constructor(executor)&#123; this.state = 'pending'; this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放法数组 this.onRejectedCallbacks = []; let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled'; this.value = value; // 一旦resolve执行，调用成功数组的函数 this.onResolvedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; let reject = reason =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected'; this.reason = reason; // 一旦reject执行，调用失败数组的函数 this.onRejectedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; try&#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; then(onFulfilled,onRejected) &#123; if (this.state === 'fulfilled') &#123; onFulfilled(this.value); &#125;; if (this.state === 'rejected') &#123; onRejected(this.reason); &#125;; // 当状态state为pending时 if (this.state === 'pending') &#123; // onFulfilled传入到成功数组 this.onResolvedCallbacks.push(()=&gt;&#123; onFulfilled(this.value); &#125;) // onRejected传入到失败数组 this.onRejectedCallbacks.push(()=&gt;&#123; onRejected(this.reason); &#125;) &#125; &#125;&#125; 解决链式调用我门常常用到new Promise().then().then(),这就是链式调用，用来解决回调地狱1、为了达成链式，我们默认在第一个then里返回一个promise。秘籍规定了一种方法，就是在then里面返回一个新的promise,称为promise2：promise2 = new Promise((resolve, reject)=&gt;{}) 将这个promise2返回的值传递到下一个then中 如果返回一个普通的值，则将普通的值传递给下一个then中 2、当我们在第一个then中return了一个参数（参数未知，需判断）。这个return出来的新的promise就是onFulfilled()或onRejected()的值规定onFulfilled()或onRejected()的值，即第一个then返回的值，叫做x，判断x的函数叫做resolvePromise 首先，要看x是不是promise。 如果是promise，则取它的结果，作为新的promise2成功的结果 如果是普通值，直接作为promise2成功的结果 所以要比较x和promise2 resolvePromise的参数有promise2（默认返回的promise）、x（我们自己return的对象）、resolve、reject resolve和reject是promise2的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Promise&#123; constructor(executor)&#123; this.state = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; let reject = reason =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; try&#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; then(onFulfilled,onRejected) &#123; // 声明返回的promise2 let promise2 = new Promise((resolve, reject)=&gt;&#123; if (this.state === 'fulfilled') &#123; let x = onFulfilled(this.value); // resolvePromise函数，处理自己return的promise和默认的promise2的关系 resolvePromise(promise2, x, resolve, reject); &#125;; if (this.state === 'rejected') &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125;; if (this.state === 'pending') &#123; this.onResolvedCallbacks.push(()=&gt;&#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125;) this.onRejectedCallbacks.push(()=&gt;&#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125;) &#125; &#125;); // 返回promise，完成链式 return promise2; &#125;&#125; 完成resolvePromise函数规定了一段代码，让不同的promise代码互相套用，叫做resolvePromise 如果 x === promise2，则是会造成循环引用，自己等待自己完成，则报“循环引用”错误 1234567let p = new Promise(resolve =&gt; &#123; resolve(0);&#125;);var p2 = p.then(data =&gt; &#123; // 循环引用，自己等待自己完成，一辈子完不成 return p2;&#125;) 1、判断x Otherwise, if x is an object or function,Let then be x.then x 不能是null x 是普通值 直接resolve(x) x 是对象或者函数（包括promise），let then = x.then 2、当x是对象或者函数（默认promise） 声明了then 如果取then报错，则走reject() 如果then是个函数，则用call执行then，第一个参数是this，后面是成功的回调和失败的回调 如果成功的回调还是pormise，就递归继续解析 3、成功和失败只能调用一个 所以设定一个called来防止多次调用 123456789101112131415161718192021222324252627282930313233343536373839404142function resolvePromise(promise2, x, resolve, reject)&#123; // 循环引用报错 if(x === promise2)&#123; // reject报错 return reject(new TypeError('Chaining cycle detected for promise')); &#125; // 防止多次调用 let called; // x不是null 且x是对象或者函数 if (x != null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; // A+规定，声明then = x的then方法 let then = x.then; // 如果then是函数，就默认是promise了 if (typeof then === 'function') &#123; // 就让then执行 第一个参数是this 后面是成功的回调 和 失败的回调 then.call(x, y =&gt; &#123; // 成功和失败只能调用一个 if (called) return; called = true; // resolve的结果依旧是promise 那就继续解析 resolvePromise(promise2, y, resolve, reject); &#125;, err =&gt; &#123; // 成功和失败只能调用一个 if (called) return; called = true; reject(err);// 失败了就失败了 &#125;) &#125; else &#123; resolve(x); // 直接成功即可 &#125; &#125; catch (e) &#123; // 也属于失败 if (called) return; called = true; // 取then出错了那就不要在继续执行了 reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; 解决其他问题1、规定onFulfilled,onRejected都是可选参数，如果他们不是函数，必须被忽略 onFulfilled返回一个普通的值，成功时直接等于 value =&gt; value onRejected返回一个普通的值，失败时如果直接等于 value =&gt; value，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误reason =&gt; throw err 2、秘籍规定onFulfilled或onRejected不能同步被调用，必须异步调用。我们就用setTimeout解决异步问题 如果onFulfilled或onRejected报错，则直接返回reject() 顺便附赠catch和resolve、reject、race、all方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235class Promise&#123; constructor(executor)&#123; this.state = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; let reject = reason =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; try&#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; then(onFulfilled,onRejected) &#123; // onFulfilled如果不是函数，就忽略onFulfilled，直接返回value onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; // onRejected如果不是函数，就忽略onRejected，直接扔出错误 onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.state === 'fulfilled') &#123; // 异步 setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;; if (this.state === 'rejected') &#123; // 异步 setTimeout(() =&gt; &#123; // 如果报错 try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;; if (this.state === 'pending') &#123; this.onResolvedCallbacks.push(() =&gt; &#123; // 异步 setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; // 异步 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0) &#125;); &#125;; &#125;); // 返回promise，完成链式 return promise2; &#125;&#125;class Promise&#123; constructor(executor)&#123; this.state = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; let reject = reason =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn=&gt;fn()); &#125; &#125;; try&#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; then(onFulfilled,onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125;; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.state === 'fulfilled') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;; if (this.state === 'rejected') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;; if (this.state === 'pending') &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0) &#125;); &#125;; &#125;); return promise2; &#125; catch(fn)&#123; return this.then(null,fn); &#125;&#125;function resolvePromise(promise2, x, resolve, reject)&#123; if(x === promise2)&#123; return reject(new TypeError('Chaining cycle detected for promise')); &#125; let called; if (x != null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if(called)return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, err =&gt; &#123; if(called)return; called = true; reject(err); &#125;) &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if(called)return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;//resolve方法Promise.resolve = function(val)&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(val) &#125;);&#125;//reject方法Promise.reject = function(val)&#123; return new Promise((resolve,reject)=&gt;&#123; reject(val) &#125;);&#125;//race方法 Promise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject) &#125;; &#125;)&#125;//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回) 进行修订，processData添加resolve传参Promise.all = function(promises) &#123; let arr = []; let i = 0; function processData(index, data, resolve) &#123; arr[index] = data; i++; if (i == promises.length) &#123; resolve(arr); &#125;; &#125;; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(data =&gt; &#123; processData(i, data, resolve); &#125;, reject); &#125;; &#125;);&#125; 如何验证我们的promise是否正确1、先在后面加上下述代码2、npm 有一个promises-aplus-tests插件 npm i promises-aplus-tests -g 可以全局安装 mac用户最前面加上sudo3、命令行 promises-aplus-tests [js文件名] 即可验证 123456789101112// 目前是通过他测试 他会测试一个对象// 语法糖Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise;//npm install promises-aplus-tests 用来测试自己的promise 符不符合promisesA+规范]]></content>
      <categories>
        <category>promise</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手四次挥手]]></title>
    <url>%2Fblog%2Fdist%2F2019%2F01%2F02%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP三次握手四次挥手TCP的状态 (SYN, FIN, ACK, PSH, RST, URG) 在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. 其中，对于我们日常的分析有用的就是前面的五个字段。 123456789SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。 其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应， 如果只是单个的一个SYN，它表示的只是建立连接。 TCP的几次握手就是通过这样的ACK表现出来的。 但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。 RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。 一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。 PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。 TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。 概念补充-TCP三次握手： TCP(Transmission Control Protocol)传输控制协议 TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接： 位码即tcp标志位，有6种标示： SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码，用小写seq代替) Acknowledge number(确认号码，用小写ack代替) TCP连接的建立（三次握手） TCP三次握手如图： TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态； TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 为什么TCP客户端最后还要发送一次确认呢？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。tcp四次挥手如图： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 01服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。]]></content>
      <categories>
        <category>tcp连接、断开连接</category>
      </categories>
      <tags>
        <tag>tcp连接、断开连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的双向绑定]]></title>
    <url>%2Fblog%2Fdist%2F2019%2F01%2F02%2Fvue%2F</url>
    <content type="text"><![CDATA[简易Vue实现 本人练习制作的(网速慢的时候，页面会显示源码)简易版vue 演示版的源码（含清晰注释/cf-result文件下）在这里 要实现简单的vue，必须掌握两点： 数据劫持，Object.defineProperty() 发布-订阅模式 创建对象的方法字面量创建法1234var people = &#123; name: 'DangChaofeng', age: '25'&#125;; 构造函数创建法123var people = new Object();people.name = 'DangChaofeng';people.age = '25'; 创建出来的对象，我们可以对它进行任意操作，增删改查均可以。 Eg: 12345678// 增加：people.gender = 'man';// 删除delete people.gender;// 修改people.name = 'Suliang';// 查(获取)people.name 但是你们有没有想过，为什么我们可以对它进行增删改查呢？我们已经知道对象是一个键值对，key-value（属性-值）的存在，少有人去知道，对象属性还有自己的特性。 对象属性的四大特性数据属性1234567var obj = new Object();Object.defineProperty(obj, 'name', &#123; value: "Tom", writable: true, configurable: true, enumerable: true&#125;); 访问器属性123456789101112var obj = new Object();var tempVar = '123';Object.defineProperty(obj, 'name', &#123; configurable: true, enumerable: true, set: function(val)&#123; tempVar = val; &#125;, get: function()&#123; return tempVar; &#125;&#125;); 这里需要说明下： 如果我们不使用Object.defineProperty()来创建属性，默认创建出来的属性的特性，均为true,如果使用Object.defineProperty()来创建属性，不写的特性，均默认为fasle。 如果我不写writable: true，则可写行性为false,赋值操作将失败。 VUE中的数据劫持，就是利用对象的访问器属性，通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情。 发布-订阅者模式 jq的$().on()、$().trigger()；就是典型的一种发布订阅模式实现。下来我们实现自己的一个简易版发布订阅者模式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Public() &#123; // 一个中间站，是用来收集存储并建立发布者和订阅者之间的联系： this.handlers = &#123;&#125;;&#125;Public.prototype = &#123; // 订阅事件 on: function(eventType, handler)&#123; var self = this; // 如果不存在这个事件，则初始化，值是一个数组。(因为对一个事件可以监听多次，挂不同的回调函数，所以事件名称对应多个事件函数). if(!(eventType in self.handlers)) &#123; self.handlers[eventType] = []; &#125; else &#123; self.handlers[eventType].push(handler); &#125; return this; &#125;, // 触发事件(发布事件) 循环执行事件对应的所有事件函数，并把参数带进入。 emit: function(eventType)&#123; var self = this; var handlerArgs = Array.prototype.slice.call(arguments,1); for(var i = 0; i &lt; self.handlers[eventType].length; i++) &#123; self.handlers[eventType][i].apply(self,handlerArgs); &#125; return self; &#125;, // 删除订阅事件 off: function(eventType, handler)&#123; var currentEvent = this.handlers[eventType]; var len = 0; if (currentEvent) &#123; len = currentEvent.length; for (var i = len - 1; i &gt;= 0; i--)&#123; if (currentEvent[i] === handler)&#123; currentEvent.splice(i, 1); &#125; &#125; &#125; return this; &#125;&#125;; var Publisher = new Public(); //订阅事件aPublisher.on('a', function(data)&#123; console.log(1 + data);&#125;);Publisher.on('a', function(data)&#123; console.log(2 + data);&#125;); //触发事件aPublisher.emit('a', '我是第1次调用的参数'); Publisher.emit('a', '我是第2次调用的参数');]]></content>
      <categories>
        <category>vue</category>
        <category>数据劫持</category>
        <category>发布订阅</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>数据劫持</tag>
        <tag>发布订阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F29%2Fmocha%2F</url>
    <content type="text"><![CDATA[mocha + chai 单元测试参考链接： 测试框架 Mocha 实例教程断言库使用 chai 主要为个人的练习记录存放，下面会展示一些或者重点易错点。 通配符（建议，如果只有一个文件的时候，不要使用{}这种匹配模式）。1234567$ mocha spec/&#123;my,awesome&#125;.js$ mocha test/unit/*.js$ mocha 'test/**/*.@(js|jsx)' // 也支持node的通配符，使用字符串包裹起来即可提示： 如果只有一个文件的时候，也需要加上, 比如 mocha test/&#123;cf,&#125;.js 否则会报错。Warning: Could not find any test files matching pattern: test/&#123;cf&#125;.jsNo test files found 递归执行（mocha默认会执行当前目录下的test目录下的文件）123456如果想执行内嵌的其他文件，比如：test/cf/**.js;test/gg/tt/**.js;这种默认使用mocha命令是不会执行的，因为他们不在test目录下。可以使用：mocha --recursive 即可以递归执行test目录下所有文件，包含深度嵌套的。 显示报告结果(--reporter参数用来指定测试报告的格式，默认是spec格式。)123$ mocha# 等同于$ mocha --reporter spec --reporters参数可以显示所有内置的报告格式。 1$ mocha --reporters 生成报告结果（使用mochawesome模块，可以生成漂亮的HTML格式的报告。）12$ npm install --save-dev mochawesome$ ../node_modules/.bin/mocha --reporter mochawesome 上面代码中，mocha命令使用了项目内安装的版本，而不是全局安装的版本，因为mochawesome模块是安装在项目内的。 然后，测试结果报告就在mochaawesome-reports子目录生成。 配置文件mocha.optsMocha允许在test目录下面，放置配置文件mocha.opts，把命令行参数写在里面。请先进入demo03目录，运行下面的命令。 1$ mocha --recursive --reporter tap 上面这个命令有两个参数--recursive、--reporter tap。 然后，把这两个参数写入test目录下的mocha.opts文件。 12--reporter tap--recursive 然后，执行mocha就能取得与第一行命令一样的效果。 1$ mocha 如果测试用例不是存放在test子目录，可以在mocha.opts写入以下内容。 12otherDirTests--recursive 上面代码指定运行otherDirTests目录及其子目录之中的测试脚本。 ES6测试如果测试脚本是用ES6写的，那么运行测试之前，需要先用Babel转码。进入demo04目录，打开test/add.test.js文件，可以看到这个测试用例是用ES6写的。 12345678910import add from '../src/add.js';import chai from 'chai';let expect = chai.expect;describe('加法函数的测试', function() &#123; it('1 加 1 应该等于 2', function() &#123; expect(add(1, 1)).to.be.equal(2); &#125;);&#125;); ES6转码，需要安装Babel。 1$ npm install babel-core babel-preset-es2015 --save-dev 然后，在项目目录下面，新建一个.babelrc配置文件。 123&#123; "presets": [ "es2015" ]&#125; 最后，使用--compilers参数指定测试脚本的转码器。 1$ ../node_modules/mocha/bin/mocha --compilers js:babel-core/register 上面代码中，--compilers参数后面紧跟一个用冒号分隔的字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用babel-core/register模块，处理一下.js文件。由于这里的转码器安装在项目内，所以要使用项目内安装的Mocha；如果转码器安装在全局，就可以使用全局的Mocha。 可以结合mocha.opts使用，或者在package.json中自定义命令去实现。 package.json（使用方式：npm run test）123"scripts": &#123; "test": "mocha --recursive --compilers js:babel-core/register" &#125; –compilers在使用过程中提示在未来版本中将被移除，推荐使用下面这种方式！ 123"scripts": &#123; "test": "mocha --recursive --require babel-core/register" &#125; Mocha.opts（使用方式： mocha）123--reporter spec--recursive--compilers js:babel-core/register –compilers在使用过程中提示在未来版本中将被移除，推荐使用下面这种方式！ 123--reporter spec--recursive--require babel-core/register]]></content>
      <categories>
        <category>mocha</category>
      </categories>
      <tags>
        <tag>mocha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词悬浮-词汇速记法3]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F27%2FEnglish3%2F</url>
    <content type="text"><![CDATA[第三堂课笔记 速记的心法： 半母语式学习 论拉丁语在英语词汇学习中的重要性 掌握拉丁语词根即可 【词根】： -vis- = -vid- (看) 、-it-(走)、-tele-(远)、-gram- = -graph- (写，画，图)、-phot-(光)、-o-(连字符)、-geo-(大地)、-electr-(电)、-phon-(声音)、-cardi-(心)、-astro-(星系)、-stud-(学习，工作)、-aud-(听)、-rad-(辐射)、-cast-(投掷)、-cass-(拿)、 建议：学会画思维导图，供复习使用。 【前缀】：（常见30个）12345678re- 往回，重复，再次super- 在上，超过pro- 向前e- 向外ad- 强调in- = im- 向内，强调，否定 self-自己 【后缀】：（常见40个）12345678910111213141516171819-or 名词或形容词后缀-able = -ible 形容词后缀，表能...的-ory = -ary 形容词或名词后缀-ice 名词后缀-ion 名词后缀-ism 名词后缀，表...主义-ist 名词或形容词后缀-ly 副词后缀-ize = -ise 动词后缀，表使动-ed 形容词或过去式或过去分词后缀-ing 形容词或动名词或现在分词后缀-e 名词或动词后缀-al 形容词或名词后缀-ent 名词或形容词后缀-o 名词后缀-ate 形容词或名词后缀-ette 名词后缀，表小-ence 名词后缀 【课后练习】： 单词 前缀1 词根1 后缀1 后缀2 含义 含义备选项 respected 1、adv.期望地 inspector 2、n.定义 retrospect 3、n.内省 finish 4、adj.无限的 expectantly 5、n.（美）公寓 department 6、vi.回顾 introspection 7、adj.受尊敬的 aprtment 8、vt.完成 definition 9、n.（大学的）科、系 Infinite 10、n.检查员]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词悬浮-词汇速记法2]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F26%2FEnglish2%2F</url>
    <content type="text"><![CDATA[第二堂课笔记 【金字塔排序的意义】：以战养战 【词根】： -nat-(生) -form-(形成)【前缀】：（常见30个）1234567891011de- 向下，分inter- 在...之间，互相trans- 通过，改变un- 否定in- 否定，内向，强调，使动non- 否定semi- 半per- 完全trans- 通过，改变de- 分，向下 【后缀】：（常见40个）123456789101112131415161718192021222324-er === or 形容词或名词后缀-ed 形容词、过去式、过去分词-less 形容词后缀，表否定-ness 名词后缀-al 形容词或名词后缀-ly 副词后缀-ity 名词后缀，表抽象含义-ics 学术名词后缀-ate 动词或形容词后缀-ion 名词后缀-ist 形容词或名词后缀-ic 形容词或名词后缀-s 名词后缀，复数名词后缀-ize 动词后缀，表使动-ism 名词后缀，表...主义-ist 名词后缀，表...主义者-ant 名词或形容词后缀-ive 名词或形容词后缀-ance 名词后缀-ing 形容词、动名词、现在分词-able 形容词后缀，表能...的-ation 复合名词后缀-ure 名词或动词后缀 【课后练习】： 单词 前缀1 词根1 后缀1 后缀2 后缀3 后缀4 后缀5 含义 含义备选项（数字填写到’含义栏’） formality 1、adj.自然主义的 denationalization 2、n.表演性 naturally 3、n.国有化 formation 4、n.变形金刚 naturalistic 5、n.跨国化 transfromational 6、n.编队 nationalization 7、adj.转换的 transnationalization 8、n.礼节 transformer 9、n.非国有化 performativity 10、adv.自然地 【听力练习推荐看片】：]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词悬浮-词汇速记法1]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F26%2FEnglish%2F</url>
    <content type="text"><![CDATA[第一堂课笔记【词根】： -elect-(采集) -press-(压力)【前缀】：（常见30个）12345678910111213141516e- 向外un- 否定self- 自己col- 在一起，强调se- 分neg- 否定over- 在上，超过de- 向下，分im- 向内，否定，强调ex- 向外un- 否定anti- 反com- 在一起re- 往回，再次i??- 否定 【后缀】：（常见40个）12345678910111213141516171819202122-or === -er 名词或形容词后缀-ed 形容词或过去式或过去分词-al 形容词或名词后缀-ant 名词或形容词后缀-ation 复合名词后缀-ic 形容词或名词后缀-ive 形容词或名词后缀-ist 名词或形容词后缀-ing 形容词或动名词或现在分词-ion 名词后缀-ism 名词后缀，表...主义-ist 名词后缀，表...主义者-ity 名词后缀，表抽象事物-ize 动词后缀，表使动-ible 形容词后缀，表能...的-ful 形容词后缀-ure 名词或动词后缀-ly 副词后缀-less 形容词后缀，表否定-ness 名词后缀 【课后练习】： 单词 前缀 2 前缀1 词根1 后缀1 后缀2 含义 含义备选项（数字填写到’含义栏’） pressurized 1、adj.抗抑郁的 impressionism 2、n.选举 expressiveness 3、vt.使减压 unselected 4、n.压缩性 antidepressant 5、n.表情丰富 collectivism 6、adj.未选择的 neglectful 7、adj.加压的 election 8、n.印象主义 depressurize 9、adj.疏忽的 compressibility 10、n.集体主义]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F26%2Fnpm-command%2F</url>
    <content type="text"><![CDATA[相信大家很多人，包括我自己，常常会对npm install –save-dev 、 npm install –save傻傻分不清楚,今天这里主要是对npm的常用命令进行一个总结。 首先，npm 是node.js自带的功能。查看npm版本 12npm -v6.4.1 升级npm版本 1234mac下: sudo npm install npm -gwindow下: npm install npm -g 使用npm安装模块 123npm install &lt;Module Name&gt;eg: 使用npm安装node中的express框架 npm install express 安装好之后，express包就会放在当前工程目录下的node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 1const express = require('express'); 默认方式为本地安装，还有一种是全局安装 1npm install express -g # 全局安装 接下来，我们列举下容易混淆的方式（注意①②的不同） 1234567891011121314151617181920212223242526npm install X: - 会把X包安装到node_modules目录中 - 不会修改package.json - 之后运行npm install命令时，不会自动安装X npm install X --save: - 会把X包安装到node_modules目录中 - 会在package.json的 ①dependencies 属性下添加X - 之后运行npm install命令时，会自动安装X到node_modules目录中 - 之后运行npm install -production或者注明NODE_ENV变量值为production时，会自动安装msbuild到 node_modules目录中npm install X --save-dev: - 会把X包安装到node_modules目录中 - 会在package.json的 ②devDependencies 属性下添加X - 之后运行npm install命令时，会自动安装X到node_modules目录中 - 之后运行npm install -production或者注明NODE_ENV变量值为production时，不会自动安装X到 node_modules目录中 npm install 使用原则 1运行时需要用到的包使用--save，否则使用--save-dev。 npm 卸载模块 123npm uninstall X卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：npm ls 更新模块 1npm update X 使用淘宝镜像 大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1npm install -g cnpm --registry=https://registry.npm.taobao.org 注意： 如果使用的是cnpm，则只需要将第一个npm命令变为cnpm即可，其他和npm命令使用方式相同。]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给无网的服务器linux环境安装nodeJs]]></title>
    <url>%2Fblog%2Fdist%2F2018%2F12%2F24%2Fno-network-linux-install-nodeJs%2F</url>
    <content type="text"><![CDATA[首先我们本地需要有一个已经下载好的node文件 [下载地址1（英文）]: (https://nodejs.org/en/download/) [下载地址2（中文）]: (http://nodejs.cn/download/) 备注： 首先通过ssh连接我们要进入的linux系统中，输入密码连接成功后，通过 uname -a 命令查看到Linux系统位数是64位（备注：x86_64表示64位系统， i686 i386表示32位系统），如图： 所以我们需要下载一个64位linux二进制包。 将下载下来的文件上传服务器并解压，查看版本正常后，进行创建全局软连接 将文件上传服务器，通过scp命令，如图： 然后再次通过ssh连接服务器后，在上面找到文件进行解压，正常流程如图： 备注：正常流程，linux支持xz解压，将文件解压为tar类型，再通过tar -xvf 解决即可。 如果你的linux不支持xz解压，请在自己本地下载配置xz并且解压为tar文件，再通过scp命令传到服务器上，再通过tar -xvf 解决即可。 最后一步，我们需要进入我所在tar解压后的文件夹下/bin 备注：进入到文件夹/bin下后，ls一下，会发现有node 和npm的存在，我们执行了node -v, npm -v；发现提示command not fount 命令不存在，因为我们没有创建全局软连接。 ln -s /dcf/node-v10.14.2-linux-x64/bin/node /usr/local/bin/ ln -s /dcf/node-v10.14.2-linux-x64/bin/npm /usr/local/bin/ 通过ln -s 创建全局软连接之后，就可以正常使用。 注意：一定要用绝对路径，不要用相对路径去配置软连接，那样会无效！ 全局软连接建立完成后，执行node -v； npm -v；发现有版本后，就说明安装成了。]]></content>
      <categories>
        <category>linux</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>node</tag>
      </tags>
  </entry>
</search>
