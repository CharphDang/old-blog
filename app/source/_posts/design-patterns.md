---
title: design-patterns
date: 2020-09-21 23:02:59
tags:
- desgin-patterns
categories:
- desgin-patterns
---

# 设计模式

> 细节分类

- 【发布订阅模式】vue 中的实现$on,$emit,$off
- 【单例模式】errorDialog 可以使用进行优化
- 【策略模式】vue 中的 form rule，配置化使用，map 结构提供策略可配置，环境类的去调用 map 中的实际方案（value）去执行，Monitor 校验配置使用的
  - { key: ()=>{} }
- 【代理模式】防抖节流， Proxy, defineProperty， 主要是替代访问本体的功能
- 【中介者模式】目的，减少耦合，eg: 购物车需求,redux, vuex 都是中介者模式，通过 store 这个中介来操作对象
- 【装饰器模式】eg: react 高阶组件, 主要是添加行为。
- 【外观模式】外面只调用一个函数， 内部判断不同的分支，实现具体的逻辑
- 【工厂模式】提供一个专门创建对象的接口
- 【建造者模式】和工厂模式相比，参与了更多创建的过程 或者更为复杂
- 【迭代器模式】
- 【享元模式】重复利用一个模特，穿不同的衣服
- 【责任链模式】中间件机制，每个中间件串行的对你的东西进行加工判断处理
- 【适配器模式】理解为外观模式？

> 大分类

- 创建型设计模式
  - 构造器模式
  - 原型模式
  - 工厂模式
    - 提供一个接口实现创建，接口内部才是调用new Class()
  - abstract factory 抽象工厂
    - 内部的class可以通过接口进行注册
  - 单例模式
  - prototype模式
    - object.create(obj, {}) 实际原理是函数委托给别人
  - module模式
    - 闭包自执行函数，暴露一个变量给外部使用，通过变量来操作内部私有属性
  - 抽象模式
  - 生成器模式（可以理解为一个生成器中包含了多个类的实例化，复杂化后的工厂模式）
- 结构型设计模式（专注类和对象的组合）
  - 代理模式
    - 提供一个代理者去帮助你操作实际的内容，代理者会考虑容错场景，提供备选方案(loading 图片的展示，等实际加载完图片，再切换新的src)
  - 外观模式
    - 外部调用统一，内部实现进行判断兼容性
  - Command（命令）模式
    - 通过不同的命令（传参）做不同的事情，常含有（关联）接收者
    - execute('requestInfo', 'Ford Mondeo', '321')
    - execute('buyVehicle', 'Ford Escort', '789')
  - Facade（外观）模式
  - Mixin模式
    - 类似于extend, merge等函数，将两个对象的key合并成一个，重复的以优先级进行覆盖
  - Decorator（装饰器）模式
  - Flyweight（享元）模式
- 行为设计模式
  - 观察者（发布订阅者模式） 关注对象之间的通信
  - 策略模式
    - 不同的算法做同一件事情

> 设计原则 `人月神话` `代码大全` `unix编程艺术`

- 开放封闭，开放扩展，封闭修改
- 依赖倒转
- 单一职责
- 里式替换
- 合成复用
  - 组合优于继承

> 学习设计模式的目的： 写着舒服，维护更舒服

> 什么时候用

- 带来开发收益
- 带来可维护性收益
- 把设计模式和组件挂钩（elementUI, antDesign）
- 没有这些，if else 就是最简单的代码
- 不要滥用
- 懒，才是程序员成长的动力

> 项目内部设计原则

- 布鲁克斯法则： 软件开发的后期，添加人力，会让项目更慢
- KISS 原则：保持简单,simple and stupid 模块设计需要遵循
- 备份
- 软件开发没有银弹
- 过早优化效应
  - 过早的优化是万恶之源

> 学习感言

```js
代码处处是模式，其实设计模式的大白话就是套路，大家都实践过很多遍之后得出的真理。学习中间，就会发现，其实自己
的代码当中很多地方已经用到了设计模式，只是你自己不知道那叫什么名字
```